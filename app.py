# ==============================================
# HIDAN GUARD
# ==============================================

import re
import hashlib
from datetime import datetime, timedelta
from flask import request, render_template, abort
from werkzeug.exceptions import TooManyRequests

# Configuração do honeypot
HONEYPOT_FIELD = "honeypot_field"
HONEYPOT_TRAP_MESSAGE = "Site protegido por HidanGuard! Acesso suspeito detectado."

def criar_tabela_ataques_hidanguard():
    """Cria tabela para registrar ataques detectados"""
    try:
        con = fdb.connect(**DB_CONFIG)
        cur = con.cursor()
        cur.execute("""
            CREATE TABLE IF NOT EXISTS HIDAN_GUARD_LOGS (
                ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                IP_ATAQUE VARCHAR(45) NOT NULL,
                DATA_ATAQUE TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                TIPO_ATAQUE VARCHAR(50) NOT NULL,
                DETALHES BLOB SUB_TYPE TEXT,
                BLOQUEADO BOOLEAN DEFAULT TRUE,
                RITUAL_COMPLETO BOOLEAN DEFAULT FALSE
            )
        """)
        con.commit()
        con.close()
    except Exception as e:
        app.logger.error(f"Erro ao criar tabela HIDAN_GUARD_LOGS: {str(e)}")

def criar_tabela_ips_bloqueados():
    """Cria tabela para armazenar IPs bloqueados"""
    try:
        con = fdb.connect(**DB_CONFIG)
        cur = con.cursor()
        cur.execute("""
            CREATE TABLE IF NOT EXISTS IPS_BLOQUEADOS (
                ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                IP VARCHAR(45) NOT NULL UNIQUE,
                DATA_BLOQUEIO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                MOTIVO VARCHAR(255),
                TENTATIVAS INTEGER DEFAULT 1
            )
        """)
        con.commit()
        con.close()
    except Exception as e:
        app.logger.error(f"Erro ao criar tabela IPS_BLOQUEADOS: {str(e)}")

def hidan_guard_honeypot():
    """Verifica se honeypot foi acionado"""
    if HONEYPOT_FIELD in request.form and request.form[HONEYPOT_FIELD]:
        ip = request.remote_addr
        user_agent = request.headers.get('User-Agent', 'Desconhecido')
        
        # Registrar o ataque
        try:
            con = fdb.connect(**DB_CONFIG)
            cur = con.cursor()
            cur.execute("""
                INSERT INTO HIDAN_GUARD_LOGS (IP_ATAQUE, TIPO_ATAQUE, DETALHES)
                VALUES (?, 'Honeypot', ?)
            """, (ip, f"User-Agent: {user_agent} | Honeypot field: {request.form[HONEYPOT_FIELD]}"))
            con.commit()
            con.close()
        except Exception as e:
            app.logger.error(f"Erro ao registrar ataque: {str(e)}")
        
        # Bloquear IP
        hidan_guard_block_ip(ip, "Honeypot trigger")
        
        return render_template('hidan_guard_trap.html', 
                            ip=ip,
                            user_agent=user_agent), 403

def hidan_guard_block_ip(ip, motivo):
    """Bloqueia um IP com estilo do Hidan"""
    try:
        con = fdb.connect(**DB_CONFIG)
        cur = con.cursor()
        
        # Verificar se o IP já está bloqueado
        cur.execute("SELECT 1 FROM IPS_BLOQUEADOS WHERE IP = ?", (ip,))
        if cur.fetchone():
            return False  # Já está bloqueado
        
        # Inserir no banco de dados
        cur.execute("""
            INSERT INTO IPS_BLOQUEADOS (IP, MOTIVO, DATA_BLOQUEIO)
            VALUES (?, ?, CURRENT_TIMESTAMP)
        """, (ip, f"Bloqueado por HidanGuard - {motivo}"))
        
        # Registrar no log de ataques
        cur.execute("""
            INSERT INTO HIDAN_GUARD_LOGS 
            (IP_ATAQUE, TIPO_ATAQUE, DETALHES, BLOQUEADO, RITUAL_COMPLETO)
            VALUES (?, ?, ?, TRUE, TRUE)
        """, (ip, "Bloqueio Manual" if motivo == "Teste" else motivo, 
             f"IP bloqueado manualmente para testes" if motivo == "Teste" else f"Bloqueado por: {motivo}"))
        
        con.commit()
        app.logger.warning(f"[HidanGuard] IP {ip} bloqueado por {motivo}")
        return True
        
    except Exception as e:
        app.logger.error(f"Erro ao bloquear IP {ip}: {str(e)}")
        return False
    finally:
        if 'con' in locals():
            con.close()

def hidan_guard_check_ip(ip):
    """Verifica se um IP está bloqueado"""
    try:
        con = fdb.connect(**DB_CONFIG)
        cur = con.cursor()
        cur.execute("SELECT 1 FROM IPS_BLOQUEADOS WHERE IP = ?", (ip,))
        return cur.fetchone() is not None
    except Exception as e:
        app.logger.error(f"Erro ao verificar IP bloqueado: {str(e)}")
        return False
    finally:
        if 'con' in locals():
            con.close()

def hidan_guard_sanitize_input(input_str):
    """Sanitiza entradas para prevenir XSS e SQL Injection"""
    if not input_str:
        return input_str
        
    # Remove tags HTML/JS
    sanitized = re.sub(r'<[^>]*>', '', str(input_str))
    # Remove caracteres perigosos para SQL
    sanitized = re.sub(r"[\;\-\-]", "", sanitized)
    return sanitized.strip()

def hidan_guard_check_sqli(input_str):
    """Detecta tentativas de SQL Injection"""
    sql_keywords = [
        'select', 'insert', 'update', 'delete', 'drop', 
        'truncate', 'create', 'alter', 'exec', 'xp_'
    ]
    
    input_str = input_str.lower()
    for keyword in sql_keywords:
        if keyword in input_str and not re.search(r'\b' + re.escape(keyword) + r'\b', input_str):
            return True
    return False

def hidan_guard_log_suspicious_activity(ip, action, details):
    """Registra atividades suspeitas"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_entry = f"[HidanGuard] {timestamp} - IP: {ip} - Ação: {action} - Detalhes: {details}\n"
    app.logger.warning(log_entry)

def hidan_guard_detect_exploit_attempts():
    """Detecta tentativas de exploração de vulnerabilidades"""
    ip = request.remote_addr
    user_agent = request.headers.get('User-Agent', '').lower()
    
    # Padrões para detecção de exploração
    exploit_patterns = [
        (r'(\%27)|(\')|(\-\-)', "SQL Injection attempt"),
        (r'((\%3D)|(=))[^\n]*((\%27)|(\')|(\-\-))', "SQL Injection attempt"),
        (r'\w*((\%27)|(\'))((\%6F)|o|(\%4F))((\%72)|r|(\%52))', "SQL Injection attempt"),
        (r'(eval\()', "Command Injection attempt"),
        (r'(union\s+select)', "SQL Injection attempt"),
        (r'(base64_decode\()', "PHP Code Injection attempt"),
        (r'(\.\.\/)', "Path Traversal attempt"),
        (r'(;\s*(sh|bash|cmd|powershell)\s*)', "Command Injection attempt"),
        (r'(<script>)', "XSS attempt"),
        (r'(document\.cookie)', "XSS attempt"),
        (r'(alert\()', "XSS attempt"),
        (r'(onerror=)', "XSS attempt"),
        (r'(javascript:)', "XSS attempt"),
        (r'(onload\s*=)', "XSS attempt"),
        (r'(onmouseover\s*=)', "XSS attempt"),
        (r'(sleep\(\d+\))', "SQL Timing Attack"),
        (r'(benchmark\(\d+)', "SQL Benchmark Attack"),
        (r'(select\s+pg_sleep\(\d+\))', "PostgreSQL Delay Attack"),
        (r'(waitfor\s+delay\s+\'\d+:\d+:\d+\')', "SQL Server Delay Attack")
    ]
    
    # Verificar query string e POST data
    sources_to_check = []
    
    if request.query_string:
        sources_to_check.append(request.query_string.decode('utf-8', 'ignore'))
    
    if request.method == "POST":
        try:
            sources_to_check.append(request.get_data().decode('utf-8', 'ignore'))
        except:
            pass
    
    for source in sources_to_check:
        for pattern, attack_type in exploit_patterns:
            try:
                if re.search(pattern, source, re.IGNORECASE):
                    hidan_guard_block_ip(ip, attack_type)
                    hidan_guard_log_suspicious_activity(ip, attack_type, f"Detectado em: {source[:100]}...")
                    return True
            except re.error:
                app.logger.error(f"Erro na expressão regular: {pattern}")
                continue
    
    # Verificar headers específicos
    suspicious_headers = {
        'User-Agent': ['sqlmap', 'nikto', 'wget', 'curl', 'hydra', 'metasploit'],
        'Accept': ['../', '\\', 'etc/passwd'],
        'Referer': ['<script>', 'javascript:']
    }
    
    for header, patterns in suspicious_headers.items():
        header_value = request.headers.get(header, '')
        for pattern in patterns:
            if pattern.lower() in header_value.lower():
                hidan_guard_block_ip(ip, f"Padrão suspeito no header {header}")
                hidan_guard_log_suspicious_activity(ip, "Header suspeito", 
                                                  f"Header {header} contém: {pattern}")
                return True
    
    return False

def hidan_guard_protect(f):
    """Decorador principal de proteção HidanGuard"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        ip = request.remote_addr
        user_agent = request.headers.get('User-Agent', '').lower()

        # Verificação de IP bloqueado
        if hidan_guard_check_ip(ip):
            abort(403, description="Seu IP foi bloqueado por HidanGuard!")

        # Detecção de exploração de vulnerabilidades
        if hidan_guard_detect_exploit_attempts():
            return render_template(
                'hidan_guard_trap.html',
                ip=ip,
                attack_type="Tentativa de exploração de vulnerabilidade"
            ), 403

        # Verificar honeypot
        honeypot_result = hidan_guard_honeypot()
        if honeypot_result:
            return honeypot_result

        # Verificar SQL Injection
        for key, value in request.args.items():
            if hidan_guard_check_sqli(value):
                hidan_guard_log_suspicious_activity(
                    ip,
                    "SQL Injection Attempt",
                    f"Parameter: {key}, Value: {value}"
                )
                hidan_guard_block_ip(ip, "Tentativa de SQL Injection")
                return render_template(
                    'hidan_guard_trap.html',
                    ip=ip,
                    user_agent=request.headers.get('User-Agent', 'Desconhecido'),
                    attack_type="SQL Injection"
                ), 403

        # Verificar XSS
        for key, value in request.args.items():
            if re.search(r'<script>|javascript:', value, re.IGNORECASE):
                hidan_guard_log_suspicious_activity(
                    ip,
                    "XSS Attempt",
                    f"Parameter: {key}, Value: {value}"
                )
                hidan_guard_block_ip(ip, "Tentativa de XSS")
                return render_template(
                    'hidan_guard_trap.html',
                    ip=ip,
                    user_agent=request.headers.get('User-Agent', 'Desconhecido'),
                    attack_type="XSS"
                ), 403

        # Verificar User-Agent suspeito
        bad_agents = ['sqlmap', 'nikto', 'wget', 'curl', 'hydra', 'metasploit']
        if any(bad in user_agent for bad in bad_agents):
            hidan_guard_block_ip(ip, "User-Agent de ferramenta de ataque")
            return render_template(
                'hidan_guard_trap.html',
                ip=ip,
                user_agent=user_agent,
                attack_type="Ferramenta de ataque detectada"
            ), 403

        return f(*args, **kwargs)
    return decorated_function

# Middlewares de segurança
@app.before_request
def hidan_guard_middleware():
    """Middleware para verificar IPs bloqueados antes de cada requisição"""
    if hidan_guard_check_ip(request.remote_addr):
        # Registrar tentativa de acesso com IP bloqueado
        try:
            con = fdb.connect(**DB_CONFIG)
            cur = con.cursor()
            cur.execute("""
                INSERT INTO HIDAN_GUARD_LOGS 
                (IP_ATAQUE, TIPO_ATAQUE, DETALHES, BLOQUEADO)
                VALUES (?, 'Tentativa com IP bloqueado', ?, TRUE)
            """, (request.remote_addr, f"Tentou acessar: {request.path}"))
            con.commit()
            con.close()
        except Exception as e:
            app.logger.error(f"Erro ao registrar tentativa com IP bloqueado: {str(e)}")
        
        return render_template('hidan_guard_blocked.html', 
                            ip=request.remote_addr,
                            path=request.path), 403

@app.after_request
def hidan_guard_security_headers(response):
    """Adiciona headers de segurança HTTP"""
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'

    response.headers['Content-Security-Policy'] = (
        "default-src 'self'; "
        "style-src 'self' https://fonts.googleapis.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com 'unsafe-inline'; "
        "font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; "
        "script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline'; "
        "img-src 'self' https://i.postimg.cc https://media.tenor.com https://media1.tenor.com data:;"
    )
    return response

# Rotas de honeypot
@app.route('/admin')
@app.route('/wp-admin')
@app.route('/.env')
@hidan_guard_protect
def honeypot_routes():
    hidan_guard_log_suspicious_activity(
        request.remote_addr,
        "Honeypot accessed",
        f"Acessou rota proibida: {request.path}"
    )
    abort(404)
